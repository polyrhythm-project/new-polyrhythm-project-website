
{% include_relative listeners.html %}
{% include scripts/scripts-common.html %}

<script>
// vim: ts=3


//////////////////////////////
//
// displayList --
//

function displayList(entries, query) {

	let dtype = "example";
	let selement = document.querySelector("#table-scope");
	if (selement && selement.value === "work") {
		dtype = "work";
	}

	reportMatches(entries);

	let output = "";

	output += "<table id='metadata-list'>";

	if (dtype === "example") {
		output += "<thead>";
		output += "<tr>";
		output += "<th title='Sort by ID' onclick='SortByWorkId(0, \"#metadata-list\")'>ID</th>";
		// missing example count
		output += "<th title='Sort by composer' onclick='SortByText(1, \"#metadata-list\")'>Composer</th>";
		output += "<th title='Sort by title' onclick='SortByText(2, \"#metadata-list\")'>Title</th>";
		output += "<th title='Sort by genre' onclick='SortByText(3, \"#metadata-list\")'>Genre</th>";
		output += "<th title='Sort by composition date' onclick='SortByText(4, \"#metadata-list\")'>Composed</th>";
		output += "<th style='padding-right:10px;' title='Sort by primier date' onclick='SortByText(5, \"#metadata-list\")'>Premiered</th>";
		output += "<th title='Sort by publication date' onclick='SortByText(6, \"#metadata-list\")'>Published</th>";
		output += "<th title='Sort by tempo' onclick='SortByTempo(7, \"#metadata-list\")'>Tempo</th>";
		output += "<th title='Sort by time signature' onclick='SortByTimeSignature(8, \"#metadata-list\")'>Start time&nbsp;signature</th>";
		output += "</tr>";
		output += "</thead>";
	} else {
		output += "<thead>";
		output += "<tr>";
		output += "<th title='Sort by composer' onclick='SortByWorkId(0, \"#metadata-list\")'>ID</th>";
		output += "<th title='Sort by composer' onclick='SortByNumber(1, \"#metadata-list\", true)'>Examples&nbsp;&nbsp;</th>";
		output += "<th title='Sort by composer' onclick='SortByText(2, \"#metadata-list\")'>Composer</th>";
		output += "<th title='Sort by title' onclick='SortByText(3, \"#metadata-list\")'>Title</th>";
		output += "<th title='Sort by genre' onclick='SortByText(4, \"#metadata-list\")'>Genre</th>";
		output += "<th title='Sort by composition date' onclick='SortByText(5, \"#metadata-list\")'>Composed</th>";
		output += "<th style='padding-right:10px;' title='Sort by premier date' onclick='SortByText(6, \"#metadata-list\")'>Premiered</th>";
		output += "<th title='Sort by publication date' onclick='SortByText(7, \"#metadata-list\")'>Published</th>";
		output += "</tr>";
		output += "</thead>";
	}

	output += "<tbody>";
	output += makeMetaTableRows(entries, dtype);
	output += "</tbody>";
	output += "</table>";

	let element = document.querySelector("div#list");
	if (query) {
		element.style.display = "none";
		let inp = document.querySelector("input#search");
		if (inp) {
			inp.value = query;
			doSearch(query);
		}
	} else if (entries.length == 0) {
		element.innerHTML = "";
	} else {
		element.innerHTML = output;
	}
	if (dtype === "example") {
		SortByNumber(SORTCOLUMN, "#metadata-list");
	} else {
		SortByWorkId(SORTCOLUMN, "#metadata-list");
	}

	if (query) {
		element.style.display = "block";
	}
}



//////////////////////////////
//
// prepareNavigationOrder --
//

function prepareNavigationOrder(selector) {
	let data = document.querySelectorAll(selector + " > tbody > tr");
	if (data.length == 0) {
		return;
	}
	let datalist = [];
	let dtype = "";
	let idIndex = 0;
	for (let i=0; i<data.length; i++) {
		let text = data[i].cells[idIndex].textContent;
		let matches;
		matches = text.match(/^[TR](\d+)/);
		if (matches) {
			dtype = "example";
			datalist.push(matches[1]);
		} else {
			dtype = "work";
			datalist.push(text);
		}
	}
	
	if (dtype == "work") {
		sessionStorage["NAVIGATION_WORK"] = JSON.stringify(datalist);
	} else{
		sessionStorage["NAVIGATION_EXAMPLE"] = JSON.stringify(datalist);
	}

}



//////////////////////////////
//
// makeMetaTableRows
//

function makeMetaTableRows(list, dtype) {
	let output = "";

	for (let i=0; i<list.length; i++) {
		if (!list[i]["Work Title"]) {
			continue;
		}
		output += "<tr class='data'>";

		output += "<td style='white-space:pre;'>";
		if (dtype === "example") {

			if (list[i]["Example No."]) {
				let number = list[i]["Example No."];
				if (list[i]["Example Dataset"] === "R") {
					output += "<b>R";
		 			output += number;
					output += "</b>";
				} else {
		 			output += "T" + number;
				}
			}

		} else {	
			let hasReserve = 0;
			let elist = list[i]["@examples"];
			for (let j=0; j<elist.length; j++) {
				if (elist[j]["Work Dataset"] === "R") {
					hasReserve = 1;
					break;
				}
			}
			if (hasReserve) {
				output += "<b>";
			}
			if (list[i]["Work ID"]) {
		 		output += list[i]["Work ID"];
			}
			if (hasReserve) {
				output += "</b>";
			}

		}
		output += "</td>";

		if (dtype === "work") {
			output += "<td style='text-align:center;'>";
			output += list[i]["@examples"].length;
			output += "</td>";
		}

		output += "<td style='min-width:150px;'>";
		if (list[i]["Composer Name"]) {
		 	output += PreparePerson(list[i]["Composer Name"]);
		}
		output += "</td>";

		output += "<td style='max-width:450px;'>";
		if (list[i]["Work Title"]) {
		 	output += PrepareTitle(list[i]["Work Title"]);
		}
		output += "</td>";

		output += "<td>";
		if (list[i]["Genre"]) {
		 	output += list[i]["Genre"];
			if (list[i]["Sub-Genre"]) {
		 		output += "/" + list[i]["Sub-Genre"];
			}
		}
		output += "</td>";

		output += "<td style='text-align:center; white-space:pre;'>";
		if (list[i]["Composition Year"]) {
		 	output += list[i]["Composition Year"];
		}
		output += "</td>";

		output += "<td style='text-align:center;'>";
		if (list[i]["First Public Performance Year"]) {
		 	output += list[i]["First Public Performance Year"];
		}
		output += "</td>";

		output += "<td style='text-align:center;'>";
		if (list[i]["First Publication Year"]) {
		 	output += list[i]["First Publication Year"];
		}
		output += "</td>";

		if (dtype === "example") {

			output += "<td style='text-align:center;'>";
			if (list[i]["Example Start Notated Beat"]) {
		 		output += createTempoMarking(list[i]["Example Start Notated Beat"], list[i]["Example Start Notated Beat Rate"]);
			}
			output += "</td>";

			output += "<td style='text-align:center;'>";
			if (list[i]["Example Start Tsig"]) {
				let value = cleanTimeSignature(list[i]["Example Start Tsig"]);
				if (value.match("\{")) {
		 			output += "unmetered";
				} else {
		 			output += value;
				}
			}
			output += "</td>";

		}

		output += "</tr>";
	}
	return output;
}



//////////////////////////////
//
// cleanTimeSignature --
//

function cleanTimeSignature(input) {
	let output = input.replace(/;\s*/, "; ");
	return output;
}



//////////////////////////////
//
// createTempoMarking --
//

function createTempoMarking(beat, value) {
	let beatpieces = beat.split(/\s*;\s*/);
	let valuepieces = value.split(/\s*;\s*/);
	if (beatpieces.length != valuepieces.length) {
		return "ERROR";
	}
	let output = "";
	for (let i=0; i<beatpieces.length; i++) {
		output += createSingleTempoMarking(beatpieces[i], valuepieces[i]);
		if (i < beatpieces.length - 1) {
			output += "; ";
		}
	}
	return output;
}


//////////////////////////////
//
// createSingleTempoMarking --
//

function createSingleTempoMarking(beat, value) {
	if (beat.match(/unavailable/)) {
		return "";
	}
	let bracket = false;
	let curley  = false;
	if (beat.match(/^[[]/)) {
		bracket = true;
		beat = beat.replace(/\[/, "", "g");
		beat = beat.replace(/\]/, "", "g");
		value = value.replace(/\[/, "", "g");
		value = value.replace(/\]/, "", "g");
	} else if (beat.match(/[{}]/)) {
		curley = true;
		beat = beat.replace(/\{/, "", "g");
		beat = beat.replace(/\}/, "", "g");
		value = value.replace(/\{/, "", "g");
		value = value.replace(/\}/, "", "g");
	}
	if (beat === "quarter") {
		beat = "&#x2669;";
	} else if (beat === "eighth") {
		beat = "&#x266A;";
	} else if (beat === "dotted-eighth") {
		beat = "&#x266A;.";
	} else if (beat === "eighth-dotted") {
		beat = "&#x266A;.";
	} else if (beat === "dotted-quarter") {
		beat = "&#x2669;.";
	} else if (beat === "quarter-dotted") {
		beat = "&#x2669;.";
	} else if (beat === "half") {
		beat = "&#x1D15E;";
	} else if (beat === "half-dotted") {
		beat = "&#x1D15E;.";
	} else if (beat === "dotted-half") {
		beat = "&#x1D15E;.";
	} else if (beat === "sixteenth") {
		beat = "&#x1D161;";
	} else if (beat === "dotted-sixteenth") {
		beat = "&#x1D161;.";
	} else if (beat === "sixteenth-dotted") {
		beat = "&#x1D161;.";
	}

	value = value.replace(/-/, "&ndash;", "g");

	let output = `${beat} = ${value}`;
	if (bracket) {
		// output = `[${output}]`;
		output = `${output}`;
	} else if (curley) {
		output = `(${output})`;
	}
	return output;
}



//////////////////////////////
//
// doSearch --
//

function doSearch(text) {

	if (!text) {
		let element = document.querySelector("input#search");
		text = element.value;
	}

	let entries = EXAMPLELIST;

	let selement = document.querySelector("#table-scope");
	if (selement && selement.value === "work") {
		// only show works, not examples
		entries = WORKLIST;
	}

	let celement = document.querySelector("#composer");
	let composer = "";
	if (celement) {
		composer = celement.value;
	}
	composer = composer.replace(/\s*,.*/, "");

	let gelement = document.querySelector("#genre");
	let genre = "";
	let subgenre = ""
	if (gelement) {
		let m = gelement.value.match(/(.*)\/(.*)/);
		if (m) {
			genre = m[1];
			subgenre = m[2];
		} else {
			genre = gelement.value;
		}
	}

	genre = genre.replace(/\s+$/, "").replace(/^\s+/, "");
	subgenre = subgenre.replace(/\s+$/, "").replace(/^\s+/, "");

	text = text.trim();
	text = escape(text);
	text = text.replace(/%u0([A-F0-9][A-F0-9][A-F0-9])/g, "&#x$1;");
	text = text.replace(/%u([A-F0-9][A-F0-9][A-F0-9][A-F0-9])/g, "&#x$1;");
	text = text.replace(/%([A-F0-9][A-F0-9])/g, "&#x$1;");
	text = text.replace(/\&#x([0-7][0-9A-F]);/g, "%$1");
	text = unescape(text);
	let fields = text.split(/\s+/);

	// filter by composer if needed
	let oldentries;
	if (composer) {
		oldentries = entries;
		entries = [];
		let testcomp;
		for (let i=0; i<oldentries.length; i++) {
			testcomp = PreparePerson(oldentries[i]["Composer Name"]);
			if (!testcomp) {
				continue;
			}
			testcomp = testcomp.replace(/\s*,.*/, "");
			if (testcomp === composer) {
				entries.push(oldentries[i]);
				continue;
			}
		}
	}

	// filter by genre/subgenre if needed
	if (genre) {
		oldentries = entries;
		entries = [];
		let greg = new RegExp(genre, "i");
		let sgreg = new RegExp(subgenre, "i");
		for (let i=0; i<oldentries.length; i++) {
			if (oldentries[i]["Genre"] && oldentries[i]["Genre"].match(greg) &&
			    oldentries[i]["Sub-Genre"] && oldentries[i]["Sub-Genre"].match(sgreg)) {
				entries.push(oldentries[i]);
			}
		}
	}

	// Filter by "Start time signature" if needed
	let tsigtype = document.querySelector("#tsigtype").value;
	if (tsigtype) {
		oldentries = entries;
		entries = [];
		for (let i=0; i<oldentries.length; i++) {
			if (tsigtype === "simple") {
				if (oldentries[i]["Example Start Tsig Type"].match(/simple/i)) {
					entries.push(oldentries[i]);
				}
			} else if (tsigtype === "compound") {
				if (oldentries[i]["Example Start Tsig Type"].match(/compound/i)) {
					entries.push(oldentries[i]);
				}
			} else if (tsigtype === "unequal") {
				if (oldentries[i]["Example Start Tsig Type"].match(/unequal/i)) {
					entries.push(oldentries[i]);
				}
			} else if (oldentries[i]["Example Start Tsig Type"] === tsigtype) {
				entries.push(oldentries[i]);
			}
		}
	}

	for (let i=0; i<fields.length; i++) {
		if (fields[i].match(/^\s*$/)) {
			continue;
		}
		oldentries = entries;
		entries = [];
		let regexp = new RegExp(fields[i], "i");
		for (let j=0; j<oldentries.length; j++) {
			if (CGI.f) {
				if (oldentries[j][CGI.f] && oldentries[j][CGI.f].match(regexp)) {
					entries.push(oldentries[j]);
					continue;
				}
			} else {
				if (oldentries[j]["Work Title"] && oldentries[j]["Work Title"].match(regexp)) {
					entries.push(oldentries[j]);
					continue;
				}
				if (oldentries[j]["Filename"] && oldentries[j]["Filename"].match(regexp)) {
					entries.push(oldentries[j]);
					continue;
				}

			}
		}
		
	}

	displayList(entries, null);
}



//////////////////////////////
//
// reportMatches --
//

function reportMatches(list) {
	let element = document.querySelector("#search-count");
	if (!element) {
		return;
	}
/*
	if (list.length == METADATA.length) {
		element.innerHTML = "";
		return;
	}
*/
	let output = "" + list.length;
	if (list.length == 1) {
		output += " entry";
	} else {
		output += " entries";
	}
	element.innerHTML = output;
}



//////////////////////////////
//
// buildComposerSelect --
//

function buildComposerSelect(list, selector) {
	let composers = {};
	let composer;
	for (let i=0; i<list.length; i++) {
		composer = PreparePerson(list[i]["Composer Name"]);
		composers[composer] = 1;
	}
	let clist = Object.keys(composers).sort();
	let element = document.querySelector(selector);
	if (!element) {
		return;
	}
	let output = "";
	output += "<option value=''>all composers</a>\n";
	for (let i=0; i<clist.length; i++) {
		if (!clist) {
			continue;
		}
		output += "<option value='" + clist[i] + "'>" + clist[i] + "</option>\n";
	}
	element.innerHTML = output;
}



//////////////////////////////
//
// buildGenreSelect --
//

function buildGenreSelect(list, selector) {
	let genres = {};
	let genre;
	let subgenre;
	for (let i=0; i<list.length; i++) {
		genre = list[i]["Genre"];
		if (!genre) {
			continue;
		}
		genre = genre.replace(/\s+$/, "").replace(/^\s+/, "");
		if (list[i]["Sub-Genre"]) {
			subgenre = list[i]["Sub-Genre"];
			subgenre = subgenre.replace(/\s+$/, "").replace(/^\s+/, "");
	 		genre += "/" + subgenre;
		}
		genres[genre] = 1;
	}
	let clist = Object.keys(genres).sort();
	let element = document.querySelector(selector);
	if (!element) {
		return;
	}
	let output = "";
	output += "<option value=''>all genres</a>\n";
	let lastgenre = "";
	for (let i=0; i<clist.length; i++) {
		if (!clist[i]) {
			continue;
		}
		let matches = clist[i].match(/([^\/]+)\/([^\/]+)/);
		let subgenre = "";
		if (matches) {
			let g = matches[1];
			subgenre = matches[2];
			if (g != lastgenre) {
				output += "<option value='" + g + "'>" + g + "</option>\n";
				lastgenre = g;
			}
		}
		output += "<option value='" + clist[i] + "'>" + "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" + subgenre + "</option>\n";
	}
	element.innerHTML = output;
}



//////////////////////////////
//
// buildTimeSignatureTypeSelect --
//

function buildTimeSignatureTypeSelect(list, selector) {
	let types = {};
	let tsigtype;
	for (let i=0; i<list.length; i++) {
		tsigtype = list[i]["Example Start Tsig Type"];
		if (!tsigtype) {
			continue;
		}
		tsigtype = tsigtype.replace(/\s+$/, "").replace(/^\s+/, "");
		types[tsigtype] = 1;
	}
	let clist = Object.keys(types).sort();
	let element = document.querySelector(selector);
	if (!element) {
		return;
	}
	let output = "";
	output += "<option value=''>all time signature types</a>\n";

	// do a fixed list of known categories
	let fixed = [];
	fixed.push("simple");
	fixed.push("simple duple");
	fixed.push("simple triple");
	fixed.push("simple quadruple");
	fixed.push("simple other");
	fixed.push("compound");
	fixed.push("compound duple");
	fixed.push("compound triple");
	fixed.push("compound quadruple");
	fixed.push("compound other");
	fixed.push("unequal");
	fixed.push("unequal duple");
	fixed.push("unequal triple");
	fixed.push("changing");
	fixed.push("polydurational");
	fixed.push("polymetric");
	fixed.push("unmetered");
	fixed.push("unavailable");

	let rfixed = {};
	let prefix = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";

	for (let i=0; i<fixed.length; i++) {
		if (fixed[i].match(/^\s*$/)) {
			continue;
		}
		rfixed[fixed[i]] = 1;

		var shortname = fixed[i];

		var matches;
		if (matches = shortname.match(/^\s*simple\s+(.+)\s*$/)) {
			shortname = `${prefix}${matches[1]}`;
		} else if (matches = shortname.match(/^\s*compound\s+(.+)\s*$/)) {
			shortname = `${prefix}${matches[1]}`;
		} else if (matches = shortname.match(/^\s*unequal\s+(.+)\s*$/)) {
			shortname = `${prefix}${matches[1]}`;
		}
		output += "<option value='" + fixed[i] + "'>" + shortname + "</option>\n";
	}

	// Append all new time signature types (add to fixed order if not wanted at end of list):
	for (let i=0; i<clist.length; i++) {
		if (clist[i].match(/^\s*$/)) {
			continue;
		}
		if (rfixed[clist[i]]) {
			continue;
		}
		var shortname = clist[i];

		var matches;
		if (matches = shortname.match(/^\s*simple\s+(.+)\s*$/)) {
			shortname = `${prefix}${matches[1]}`;
		} else if (matches = shortname.match(/^\s*compound\s+(.+)\s*$/)) {
			shortname = `${prefix}${matches[1]}`;
		} else if (matches = shortname.match(/^\s*unequal\s+(.+)\s*$/)) {
			shortname = `${prefix}${matches[1]}`;
		}
		output += "<option value='" + clist[i] + "'>" + shortname + "</option>\n";
	}

	element.innerHTML = output;
}


</script>




