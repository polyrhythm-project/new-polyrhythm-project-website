
{% include_relative listeners.html %}
{% include scripts/scripts-common.html %}

<script>
// vim: ts=3


//////////////////////////////
//
// createWorkList -- Convert the individual examples in to an array of
//     objects by work id.
//

function createWorkList(exampleList) {
	// console.error("EXAMPLE LIST", exampleList);
	let works = {};
	for (let i=0; i<exampleList.length; i++) {
		let workid = exampleList[i]["Work ID"];
		if (!workid) {
			console.warn("NO WORKID FOR", exampleList[i]);
			continue;
		}
		if (!workid.match(/^[A-Z][a-z][a-z]-\d+x?$/)) {
			console.error("WORKID", workid, "IS INVALID FOR", exampleList[i]);
			continue;
		}
		if (typeof works[workid] === "undefined") {
			works[workid] = [ exampleList[i] ];
		} else {
			works[workid].push(exampleList[i]);
		}
	}

	return works;
}


//////////////////////////////
//
// displayScoreList --
//

function displayScoreList(workList) {
	document.body.classList.remove("waiting");


	if (!WORKLIST) {
		WORKLIST = workList;
	}
	if (!workList) {
		workList = WORKLIST;
	}

	let sortedList = [];

	let sortElement = document.querySelector("#sort-method");
	let sortType = sortElement.value;
	console.warn("SORT TYPE", sortType);

	if (sortType === "workid") {

		let keys = Object.getOwnPropertyNames(workList);
		keys.sort(function (a, b) {
			let matchesA = a.match(/^(.*)-(.*)(x?)/);
			let matchesB = b.match(/^(.*)-(.*)(x?)/);
			let nameA = matchesA[1];
			let nameB = matchesB[1];
			let numA  = parseInt(matchesA[2]);
			let numB  = parseInt(matchesB[2]);
			let extA  = matchesA[3] || "";
			let extB  = matchesB[3] || "";
			if (nameA !== nameB) {
				return nameA.localeCompare(nameB);
			}
			if (numA != numB) {
				return numA - numB;
			}
			// Deal with such as Mai-6x:
			if (extA == "") {
				return -1;
			} else {
				return 1;
			}
		});
		for (let i=0; i<keys.length; i++) {
			sortedList[i] = workList[keys[i]];
		}

	} else if (sortType === "exid") {
		let keys = Object.getOwnPropertyNames(workList);
		for (let i=0; i<keys.length; i++) {
			sortedList[i] = workList[keys[i]];
		}

		sortedList.sort(function (a, b) {
			let exidA = a[0].Filename.replace(/_.*/, "").replace(/^[TR]/, "");
			let exidB = b[0].Filename.replace(/_.*/, "").replace(/^[TR]/, "");
			return exidA.localeCompare(b);
		});

		console.warn("NEW SORTED LIST", sortedList);
	} else if (sortType === "year") {

		let keys = Object.getOwnPropertyNames(workList);
		keys.sort(function (a, b) {
			let matchesA;
			let matchesb;
			let yearA = workList[a][0]["Composition Year"] || "";
			let yearB = workList[b][0]["Composition Year"] || "";
			matchesA = yearA.match(/(1[89]\d{2})/);
			if (matchesA) {
				yearA = parseInt(matchesA[1]);
			}
			matchesB = yearB.match(/(1[89]\d{2})/);
			if (matchesB) {
				yearB = parseInt(matchesB[1]);
			}
			if (yearA != yearB) {
				return yearA - yearB;
			}
			matchesA = a.match(/^(.*)-(.*)(x?)/);
			matchesB = b.match(/^(.*)-(.*)(x?)/);
			let nameA = matchesA[1];
			let nameB = matchesB[1];
			let numA  = parseInt(matchesA[2]);
			let numB  = parseInt(matchesB[2]);
			let extA  = matchesA[3] || "";
			let extB  = matchesB[3] || "";
			if (nameA !== nameB) {
				return nameA.localeCompare(nameB);
			}
			if (numA != numB) {
				return numA - numB;
			}
			// Deal with such as Mai-6x:
			if (extA == "") {
				return -1;
			} else {
				return 1;
			}
		});
		for (let i=0; i<keys.length; i++) {
			sortedList[i] = workList[keys[i]];
		}
	}

	let container = document.querySelector("#score-list");
	if (!container) {
		console.error("Error: cannot find score list container");
		return;
	}

	let output = "";
	output += "<table id='work-list'>";

	for (let i=0; i<sortedList.length; i++) {
		output += generateWorkEntry(sortedList[i]);
	}

	output += "</table>";
	container.innerHTML = output;

}



//////////////////////////////
//
// printScoreEntry -- print one entry in the score list.
//
// Example entry:
// 
// Composer Name: "Martin≈Ø, Bohuslav (Jan)"
// Composition Year: "1940"
// Composition Year(s): "1940"
// E0 Edition/Catalogue Number: "Not listed"
// E0 Publisher: "Associated Music Publishers"
// E1 Edition/Catalogue number: "Not listed"
// E1 Publication Year: "1951"
// E1 Publisher: "Associated Music Publishers"
// Example ID: "Mau-63/5/30-33"
// Filename: "T500_Mau-w63p5m30-33"
// Publisher (Abbreviation): "AMP"
// Reason for use: "Metadata Validation"
// Source Location (UBC Library call number; URL; print source purchased from publishing company; nkoda; hathi trust catalogue number): "IMSLP: https://imslp.org/wiki/Fantaisie_et_Toccata%2C_H.281_(Martin%C5%AF%2C_Bohuslav)"
// Work ID: "Mau-63"
// Work Name: "Fantaisie et Toccata pour piano"
// Work Title: "Fantazie a toccata (Fantasy and Toccata) for Piano"
//

function generateWorkEntry(entry) {
	let first = entry[0];
	if (!first) {
		console.warn("ERROR: Problem with entry", entry);
		return;
	}

	let workid   = first["Work ID"] || "";
	let composer = first["Composer Name"] || "";
	let title    = first["Work Title"] || "";
	let year     = first["Composition Year"] || "";
	if (year.match(/\(/)) {
		year = year.replace(/ \(/g, "; ").replace(/\)/g, " ");
	}
	let e = [];
	for (let i=0; i<entry.length; i++) {
		let eid = entry[i]["Filename"];
		eid = eid.replace(/_.*/, "");
		let filename = entry[i]["Filename"];
		let exid = "";
		let matches = filename.match(/^[RT]?(\d+[ABCD]?x?)_/);
		if (matches) {
			exid = matches[1];
		}
		matches = exid.match(/(\d+)/);
		let num = 0;
		if (matches) {
			num = matches[1];
		}
		
		if (!num) {
			console.warn("Missing example number in entry", entry[i]);
			continue;
		}
		if (!exid) {
			console.warn("Missing example ID", entry[i]);
			continue;
		}
		e[i] = { eid: eid, exid: exid, num: num };
	}

	let elist = "";
	for (let i=0; i<e.length; i++) {
		elist += `<a href="/example/?id=${e[i].eid}">${e[i].eid}</a>`;
		if (i < e.length - 1) {
			elist += ", ";
		}
	}

	let e0name = first["Work Name"] || "";
	let e0pub = first["E0 Publisher"] || "";
	let e0cat = first["E0 Edition/Catalogue Number"] || "";
	if (e0cat.match(/not listed/i)) {
		e0cat = "";
	}
	e0cat = e0cat.replace("(PP)", "");
	if (!e0cat.match(/^\s*$/)) {
		e0pub += ":";
	}

	let e1pub  = first["E1 Publisher"] || "";
	let e1cat  = first["E1 Edition/Catalogue number"] || ""
	e1cat = e1cat.replace(/\(?not listed\)?/gi, " ");
	if (!e1cat.match(/^\s*$/)) {
		e1pub += ":";
	}
	let e1year = first["E1 Edition Year"] || "";
	if (e1year.match(/\(/)) {
		if (!e1year.match(/; /)) {
			e1year = e1year.replace(/\(/g, "; ").replace(/\)/, " ");
		}
	}
	if (e1year) {
		e1year = `(${e1year})`;
	}
	if (e1year.match(/Not listed/)) {
		e1year = "";
	}
	let e1url  = first["Source Location (UBC Library call number; URL; print source purchased from publishing company; nkoda; hathi trust catalogue number)"] || "";
	if (!e1url.match(/http/)) {
		e1url = "";
	}
	e1url = e1url.replace(/.*http/, "http");
	
	////////////////////////////////////////////////////////////////

	let output = "";
	output += "<tr>";

	output += "<td>";
	output += `<span class="workid" title="${composer}">${workid}`;
	output += `</span>`;
	output += "</td>";

	output += "<td class='workinfo'>";
	output += `<span class="worktitle">${title}`;
	if (year.match(/\(/)) {
		if (!year.match(/; /)) {
			year = year.replace(/\(/g, "; ").replace(/\)/, " ");
		}
	}
	if (year) {
		output += ` (${year})`;
	}
	output += `</span>`;
	output += "<br/>";
	if (e.length == 1) {
		output += "<span class='example'>Example:</span> ";
	} else {
		output += "<span class='example'>Examples:</span> ";
	}
	output += elist;
	
	output += "<ul class='publication'>";
	if (e0pub) {
		output += `<li><span class="publication">${e0pub} <span class="catnum">${e0cat}</span></span></li>\n`;
	}
	if (e1pub) {
		output += "<li>";
		if (e1url) {
			output += `<a target="_blank" href="${e1url}">`;
		}
		output += `<span class="publication">${e1pub} <span class="catnum">${e1cat}</span> ${e1year}</span>\n`;
		if (e1url) {
			output += `</a>`;
		}
		output += "</li>";
	}
	output += "</ul>";
	
	output += "</td>";

	output += "</tr>";
	return output;
}


</script>




