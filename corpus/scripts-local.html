

<script>
// vim: ts=3:nowrap

//////////////////////////////
//
// displayExampleStartTsigTypeRds --
//

function displayExampleStartTsigTypeRds() {
	let selector = document.querySelector("#ExampleStartTsigTypeRds");
	if (!selector) {
		console.warn("Cannot find #ExampleStartTsigTypeRds");
		return;
	}
	let data = {};
	for (let i=0; i<EXAMPLELIST.length; i++) {
		let dataset = EXAMPLELIST[i][INDEX_Example_Dataset];
		if (!dataset.match(/^R/)) {
			continue;
		}
		let value = EXAMPLELIST[i][INDEX_Example_Start_Tsig_Type];
		if (data[value]) {
			data[value]++;
		} else {
			data[value] = 1;
		}
	}

	let color = {};
	color["compound duple"]       = "rgb(44,175,254)";
	color["compound other"]       = "rgb(44,175,254)";
	color["compound quadruple"]   = "rgb(44,175,254)";
	color["compound triple"]      = "rgb(44,175,254)";
	color["other changing"]       = "#544fc5";
	color["other polydurational"] = "#544fc5";
	color["other polymetric"]     = "#544fc5";
	color["other unmetered"]      = "#544fc5";
	color["simple duple"]         = "#00e272";
	color["simple other"]         = "#00e272";
	color["simple quadruple"]     = "#00e272";
	color["simple triple"]        = "#00e272";
	color["unavailable"]          = "#fe6a35";
	color["unequal duple"]        = "#fe6a35";
	color["unequal triple"]       = "#fe6a35";

	let vdata = [];
	let keys = Object.keys(data).sort();
	for (let i=0; i<keys.length; i++) {
		let entry = {"name": keys[i], "y": data[keys[i]]};
		vdata.push(entry);
	}

	vdata.sort((a, b) => {
		if (a.name < b.name) {
			return -1;
		}
		if (a.name > b.name) {
			return 1;
		}
		return 0;
	});
	for (let i=0; i<vdata.length; i++) {
		vdata[i].name = vdata[i].name.replace(/.*\t/, "");
		if (color[vdata[i].name]) {
			vdata[i].color = color[vdata[i].name];
		} else {
			vdata[i].color = "#000000";
		}
	}

	Highcharts.chart('ExampleStartTsigTypeRds', {
		chart: { type: 'pie' },
		title: { text: null },
		credits: { enabled: false },
		tooltip: { pointFormat: '{series.name}: <b>{point.percentage:.1f}%</b>' },
		accessibility: { point: { valueSuffix: '%' } },
		plotOptions: {
			pie: {
				allowPointSelect: true,
				cursor: 'pointer',
				dataLabels: {
					enabled: true,
					format: '<b>{point.name}</b>: {point.percentage:.1f} %',
					connectorColor: 'silver',
					style: {
						color: 'black',
						textOutline: 'none'
					}
				}
			}
		},
		series: [{ name: 'Share', data: vdata }]
	});

}



//////////////////////////////
//
// displayExampleStartTsigTypeTds --
//

function displayExampleStartTsigTypeTds() {
	let selector = document.querySelector("#ExampleStartTsigTypeTds");
	if (!selector) {
		console.warn("Cannot find #ExampleStartTsigTypeTds");
		return;
	}
	let data = {};
	for (let i=0; i<EXAMPLELIST.length; i++) {
		let dataset = EXAMPLELIST[i][INDEX_Example_Dataset];
		if (!dataset.match(/^T/)) {
			continue;
		}
		let value = EXAMPLELIST[i][INDEX_Example_Start_Tsig_Type];
		if (data[value]) {
			data[value]++;
		} else {
			data[value] = 1;
		}
	}

	let color = {};
	color["compound duple"]       = "rgb(44,175,254)";
	color["compound other"]       = "rgb(44,175,254)";
	color["compound quadruple"]   = "rgb(44,175,254)";
	color["compound triple"]      = "rgb(44,175,254)";
	color["other changing"]       = "#544fc5";
	color["other polydurational"] = "#544fc5";
	color["other polymetric"]     = "#544fc5";
	color["other unmetered"]      = "#544fc5";
	color["simple duple"]         = "#00e272";
	color["simple other"]         = "#00e272";
	color["simple quadruple"]     = "#00e272";
	color["simple triple"]        = "#00e272";
	color["unavailable"]          = "#fe6a35";
	color["unequal duple"]        = "#fe6a35";
	color["unequal triple"]       = "#fe6a35";

	let vdata = [];
	let keys = Object.keys(data).sort();
	for (let i=0; i<keys.length; i++) {
		let entry = {"name": keys[i], "y": data[keys[i]]};
		vdata.push(entry);
	}

	vdata.sort((a, b) => {
		if (a.name < b.name) {
			return -1;
		}
		if (a.name > b.name) {
			return 1;
		}
		return 0;
	});
	for (let i=0; i<vdata.length; i++) {
		vdata[i].name = vdata[i].name.replace(/.*\t/, "");
		if (color[vdata[i].name]) {
			vdata[i].color = color[vdata[i].name];
		} else {
			vdata[i].color = "#000000";
		}
	}

	Highcharts.chart('ExampleStartTsigTypeTds', {
		chart: { type: 'pie' },
		title: { text: null },
		credits: { enabled: false },
		tooltip: { pointFormat: '{series.name}: <b>{point.percentage:.1f}%</b>' },
		accessibility: { point: { valueSuffix: '%' } },
		plotOptions: {
			pie: {
				allowPointSelect: true,
				cursor: 'pointer',
				dataLabels: {
					enabled: true,
					format: '<b>{point.name}</b>: {point.percentage:.1f} %',
					connectorColor: 'silver',
					style: {
						color: 'black',
						textOutline: 'none'
					}
				}
			}
		},
		series: [{ name: 'Share', data: vdata }]
	});

}



//////////////////////////////
//
// displayExampleStartTsigTypeFds --
//

function displayExampleStartTsigTypeFds() {
	let selector = document.querySelector("#ExampleStartTsigTypeFds");
	if (!selector) {
		console.warn("Cannot find #ExampleStartTsigTypeFds");
		return;
	}
	let data = {};
	for (let i=0; i<EXAMPLELIST.length; i++) {
		let dataset = EXAMPLELIST[i][INDEX_Example_Dataset];
		let value = EXAMPLELIST[i][INDEX_Example_Start_Tsig_Type];
		if (data[value]) {
			data[value]++;
		} else {
			data[value] = 1;
		}
	}

	let color = {};
	color["compound duple"]       = "rgb(44,175,254)";
	color["compound other"]       = "rgb(44,175,254)";
	color["compound quadruple"]   = "rgb(44,175,254)";
	color["compound triple"]      = "rgb(44,175,254)";
	color["other changing"]       = "#544fc5";
	color["other polydurational"] = "#544fc5";
	color["other polymetric"]     = "#544fc5";
	color["other unmetered"]      = "#544fc5";
	color["simple duple"]         = "#00e272";
	color["simple other"]         = "#00e272";
	color["simple quadruple"]     = "#00e272";
	color["simple triple"]        = "#00e272";
	color["unavailable"]          = "#fe6a35";
	color["unequal duple"]        = "#fe6a35";
	color["unequal triple"]       = "#fe6a35";

	let vdata = [];
	let keys = Object.keys(data).sort();
	for (let i=0; i<keys.length; i++) {
		let entry = {"name": keys[i], "y": data[keys[i]]};
		vdata.push(entry);
	}

	vdata.sort((a, b) => {
		if (a.name < b.name) {
			return -1;
		}
		if (a.name > b.name) {
			return 1;
		}
		return 0;
	});
	for (let i=0; i<vdata.length; i++) {
		vdata[i].name = vdata[i].name.replace(/.*\t/, "");
		if (color[vdata[i].name]) {
			vdata[i].color = color[vdata[i].name];
		} else {
			vdata[i].color = "#000000";
		}
	}

	Highcharts.chart('ExampleStartTsigTypeFds', {
		chart: { type: 'pie' },
		title: { text: null },
		credits: { enabled: false },
		tooltip: { pointFormat: '{series.name}: <b>{point.percentage:.1f}%</b>' },
		accessibility: { point: { valueSuffix: '%' } },
		plotOptions: {
			pie: {
				allowPointSelect: true,
				cursor: 'pointer',
				dataLabels: {
					enabled: true,
					format: '<b>{point.name}</b>: {point.percentage:.1f} %',
					connectorColor: 'silver',
					style: {
						color: 'black',
						textOutline: 'none'
					}
				}
			}
		},
		series: [{ name: 'Share', data: vdata }]
	});

}



//////////////////////////////
//
// displayPolymetricCategories --
//

function displayPolymetricCategories() {
	let selector = document.querySelector("#PolymetricCategories");
	if (!selector) {
		console.warn("Cannot find #PolymetricCategories");
		return;
	}
	let data = {};
	for (let i=0; i<EXAMPLELIST.length; i++) {
		let tsigType = EXAMPLELIST[i][INDEX_Example_Start_Tsig_Type];
		if (!tsigType) {
			continue;
		}
		if (!tsigType.match(/poly/, "i")) {
			continue;
		}
		let poly = EXAMPLELIST[i][INDEX_Example_Start_Tsig];
		if (!poly.match(/[=;]/)) {
			// console.log("REJECTING", poly);
			continue;
		}
		if (poly.match(/[+]/)) {
			// console.log("REJECTING", poly);
			continue;
		}
		let matches = poly.match(/(.*\d)\(\d+\/\d+\)(;.*)/);
		if (matches) {
			poly = `${matches[1]}${matches[2]}`;
		}
		poly = poly.replace(/[(){}]/g, "");
		poly = poly.replace(/'\d+\/\d+\s*($|;)/g, ";");
		poly = poly.replace(/\s*;\s*/g, ";");
		poly = poly.replace(/\s*;$/, "");
		let pieces = poly.split(/;/);
		if (pieces.length == 2) {
			// Flip order to merge similar polymeters:
			if (pieces.length == 2) {
				matches = pieces[0].match(/^(\d+)\/(\d+)$/);
				if (matches) {
					let top1 = matches[1];
					let bot1 = matches[2];
					matches = pieces[1].match(/^(\d+)\/(\d+)$/);
					if (matches) {
						let top2 = matches[1];
						let bot2 = matches[2];
						if (top2 < top1) {
							poly = `${top2}/${bot2};${top1}/${bot1}`;
						}
					}
				}
			}
		}
	
		if (data[poly]) {
			data[poly]++;
		} else {
			data[poly] = 1;
		}
	}

	let vdata = [];
	let keys = Object.keys(data).sort();
	for (let i=0; i<keys.length; i++) {
		let entry = {"name": keys[i], "y": data[keys[i]]};
		vdata.push(entry);
	}

	Highcharts.chart('PolymetricCategories', {
		chart: { type: 'pie' },
		title: { text: null },
		credits: { enabled: false },
		tooltip: { pointFormat: '{series.name}: <b>{point.y}</b>' },
		accessibility: { point: { valueSuffix: '' } },
		plotOptions: {
			pie: {
				allowPointSelect: true,
				cursor: 'pointer',
				dataLabels: {
					enabled: true,
					format: '<b>{point.name}</b>: {point.y}',
					connectorColor: 'silver',
					style: {
						color: 'black',
						textOutline: 'none'
					}
				}
			}
		},
		series: [{ name: 'Count', data: vdata }]
	});
}



//////////////////////////////
//
// displayCountryCityTable --
//

function displayContryCityTable() {
	let element = document.querySelector("#country-city-table");
	if (!element) {
		console.warn("Cannot find #country-city-table");
	}
	let cities = [];
	let countries = [];
	let keys = Object.keys(WORKINDEX);
	for (let i=0; i<keys.length; i++) {
		let city = WORKINDEX[keys[i]][0][INDEX_Premiere_Location];
		city = city.replace(/,\s*/g, ", ");
		let cc = city.split(/\s*;\s*/);
		for (let j=0; j<cc.length; j++) {
			cities.push(cc[j]);
			let matches = cc[j].match(/,\s*([^,]*)\s*$/);
			if (matches) {
				let country = matches[1];
				countries.push(country);
			}
		}
	}

	let rcities = {};
	for (let i=0; i<cities.length; i++) {
		if (rcities[cities[i]]) {
			rcities[cities[i]]++;
		} else {
			rcities[cities[i]] = 1;
		}
	}

	let rcountries = {};
	for (let i=0; i<countries.length; i++) {
		if (rcountries[countries[i]]) {
			rcountries[countries[i]]++;
		} else {
			rcountries[countries[i]] = 1;
		}
	}

	let entries = Object.entries(rcities);
	entries.sort(([, value1], [, value2]) => value2 - value1);
	entries.sort(([key1, value1], [key2, value2]) => {
		if (value2 !== value1) {
			return value2 - value1;
		} else {
			return key1.localeCompare(key2);
		}
	});
	rcities = Object.fromEntries(entries);

	entries = Object.entries(rcountries);
	entries.sort(([key1, value1], [key2, value2]) => {
		if (value2 !== value1) {
			return value2 - value1;
		} else {
			return key1.localeCompare(key2);
		}
	});
	rcountries = Object.fromEntries(entries);

	// console.warn("RCITIES", rcities);
	// console.warn("RCOUNTRIES", rcountries);

	let output = "";
	output += `<table class="dual">`;
	output += "<tr><td>";


	keys = Object.keys(rcountries);
	output += `<div class="counting">${keys.length} countries:</div>`;
	output += `<table class="country">`;
	output += "<tr><th>Count</th><th>Country</th></tr>";
	for (let i=0; i<keys.length; i++) {
		output += "<tr>";
		output += `<td>${rcountries[keys[i]]}</td>`;
		output += `<td>${keys[i]}</td>`;
		output += "</tr>";
	}
	output += "</table>";


	output += "</td><td>";

	keys = Object.keys(rcities);
	output += `<div class="counting">${keys.length} cities:</div>`;
	output += `<table class="city">`;
	output += "<tr><th>Count</th><th>City</th></tr>";
	for (let i=0; i<keys.length; i++) {
		output += "<tr>";
		output += `<td>${rcities[keys[i]]}</td>`;
		output += `<td>${keys[i]}</td>`;
		output += "</tr>";
	}
	output += "</table>";


	output += "</td></tr>";
	output += "<table>";

	element.innerHTML = output;

}



//////////////////////////////
//
// displayExampleByComposers --
//

function displayExampleByComposers() {
	let data = {};
	for (let i=0; i<EXAMPLELIST.length; i++) {
		let composer = GetComposerLastName(EXAMPLELIST[i][INDEX_Composer_Name]);
		if (data[composer]) {
			data[composer]++;
		} else {
			data[composer] = 1;
		}
	}

	let vdata = [];
	let keys = Object.keys(data).sort();
	for (let i=0; i<keys.length; i++) {
		let entry = [ keys[i], data[keys[i]] ];
		vdata.push(entry);
	}

console.log("VDATA", vdata);

	var colors = [
		'#FF4500', '#FF6347', '#FF8C00', '#FF4500', '#CD5C5C', // Reds and Oranges
		'#8B0000', '#B22222', '#228B22', '#32CD32', '#008000', // Greens
		'#006400', '#ADFF2F', '#00FF7F', '#2E8B57', '#3CB371', // More Greens
		'#0000CD', '#00008B', '#4169E1', '#4682B4', '#5F9EA0', // Blues
		'#6495ED', '#6A5ACD', '#7B68EE', '#8A2BE2', '#4B0082', // More Blues
		'#9932CC', '#8B008B', '#800080', '#9370DB', '#9400D3', // Purples
		'#BA55D3', '#DA70D6', '#EE82EE', '#DDA0DD', '#FF00FF', // More Purples
	];

	let id = "ExamplesByComposers";
	WordCloud(document.getElementById(id), {
		list: vdata,
		gridSize: Math.round(16 * document.getElementById(id).offsetWidth / 1024),
		weightFactor: function (size) {
			return size * (document.getElementById(id).offsetWidth / 1024);
		},
		fontFamily: 'Helvetica, Arial, sans-serif',
		color: function (word, weight, fontSize, distance, theta) {
			return colors[Math.floor(Math.random() * colors.length)];
		},
		rotateRatio: 0.8, // Higher ratio for more rotated words
		rotationSteps: 12, // More rotation steps for varied angles
		backgroundColor: '#fff',
		drawOutOfBound: false,
		shuffle: true,
		shape: 'circle'
	});

}


//////////////////////////////
//
// displayLengthOfExamplesByComposer --
//

function displayLengthOfExamplesByComposer() {
	let element = document.querySelector("#LengthOfExamplesByComposer");
	if (!element) {
		console.warn("Warning: cannot find #LengthOfExamplesByComposer");
		return;
	}
	let data = [];
	for (let i=0; i<EXAMPLELIST.length; i++) {
		let entry = {};
		let duration = EXAMPLELIST[i][INDEX_Example_Timestamp_Duration];
		if (!duration.match(/^\d+$/)) {
			// console.warn("Strange duration:", duration, "FOR", EXAMPLELIST[i]);
			continue;
		}
		entry.value = duration;
		let composer = EXAMPLELIST[i][INDEX_Composer_Name];
		entry.category = GetComposerLastName(composer);
		data.push(entry);
	}
	let counts = {};
	let values = {};
	for (let i=0; i<data.length; i++) {
		let composer = data[i].category;
		if (counts[composer]) {
			counts[composer]++;
		} else {
			counts[composer] = 1;
		}
		if (values[composer]) {
			values[composer].push(data[i].value);
		} else {
			values[composer] = [ data[i].value ];
		}
	}
	for (let i=0; i<data.length; i++) {
		data[i].category += ` (${counts[data[i].category]})`;
	}

	let keys = Object.keys(values).sort();
	let medians = {}
	for (let i=0; i<keys.length; i++) {
		values[keys[i]].sort((a, b) => a - b);
		let median;
		let middle = Math.floor(values[keys[i]].length / 2);
		let value1 = parseInt(values[keys[i]][middle - 1]);
		let value2 = parseInt(values[keys[i]][middle]);
		if (values[keys[i]].length % 2 === 0) {
			median = (value1 + value2) / 2;
		} else {
			median = value2;
		}
		medians[keys[i]] = median;
	}

	// console.log("DATA", data);
	// console.log("VALUES", values);
	// console.log("MEDIANS", medians);

    var spec = {
      "$schema": "https://vega.github.io/schema/vega-lite/v5.json",
      "description": "A bar and whisker plot example categorized by a specific category with x-axis labels angled by 45 degrees.",
      "width": 600,
      "height": 600,
      "data": {
        "values": data
      },
      "transform": [
        {
          "aggregate": [
            {"op": "count", "as": "count"},
            {"op": "max", "field": "value", "as": "max_value"}
          ],
          "groupby": ["category", "value"]
        },
        {
          "window": [{"op": "rank", "as": "rank"}],
          "groupby": ["category", "value"]
        },
        {
          "calculate": "(datum.rank - 1 - (datum.count - 1) / 2) * 0.2",
          "as": "jitter"
        },
        {
          "joinaggregate": [
            {"op": "median", "field": "value", "as": "median_value_per_category"},
            {"op": "max", "field": "value", "as": "max_value_per_category"}
          ],
          "groupby": ["category"]
        }
      ],
      "layer": [
        {
          "mark": "bar",
          "encoding": {
            "x": {
              "field": "category",
              "type": "nominal",
              "axis": {
                "title": "Composer",
                "labelAngle": 45
              }
            },
            "y": {
              "field": "value",
              "type": "quantitative",
              "aggregate": "q1",
              "axis": {"title": "Duration [seconds]"}
            },
            "y2": {
              "field": "value",
              "type": "quantitative",
              "aggregate": "q3"
            }
          }
        },
        {
          "mark": "rule",
          "encoding": {
            "x": {"field": "category", "type": "nominal"},
            "y": {"field": "value", "type": "quantitative", "aggregate": "min"},
            "y2": {"field": "value", "type": "quantitative", "aggregate": "max"}
          }
        },
        {
          "mark": {
            "type": "tick",
            "color": "black",
            "thickness": 2
          },
          "encoding": {
            "x": {"field": "category", "type": "nominal"},
            "y": {"field": "value", "type": "quantitative", "aggregate": "min"}
          }
        },
        {
          "mark": {
            "type": "tick",
            "color": "black",
            "thickness": 2
          },
          "encoding": {
            "x": {"field": "category", "type": "nominal"},
            "y": {"field": "value", "type": "quantitative", "aggregate": "max"}
          }
        },
        {
          "mark": {
            "type": "point",
            "color": "black",
            "size": 25,
            "filled": true
          },
          "encoding": {
            "x": {
              "field": "category",
              "type": "nominal",
              "axis": {"title": "Composer"},
              "offset": {"field": "jitter"}
            },
            "y": {"field": "value", "type": "quantitative"}
          }
        },
        {
          "mark": {
            "type": "text",
            "align": "center",
            "baseline": "bottom",
            "dy": -5,
            "fontSize": 10,
            "fontWeight": "bold",
            "color": "red"
          },
          "transform": [
            {
              "filter": "datum.value == datum.max_value_per_category"
            }
          ],
          "encoding": {
            "x": {"field": "category", "type": "nominal"},
            "y": {
              "field": "max_value_per_category",
              "type": "quantitative",
              "offset": 10
            },
            "text": {
              "field": "median_value_per_category",
              "type": "quantitative",
              "format": ".1f"
            }
          }
        }
      ]
    };    var spec = {
      "$schema": "https://vega.github.io/schema/vega-lite/v5.json",
      "description": "A bar and whisker plot example categorized by a specific category with x-axis labels angled by 45 degrees.",
      "width": 600,
      "height": 600,
      "data": {
        "values": data
      },
      "transform": [
        {
          "aggregate": [
            {"op": "count", "as": "count"},
            {"op": "max", "field": "value", "as": "max_value"}
          ],
          "groupby": ["category", "value"]
        },
        {
          "window": [{"op": "rank", "as": "rank"}],
          "groupby": ["category", "value"]
        },
        {
          "calculate": "(datum.rank - 1 - (datum.count - 1) / 2) * 0.2",
          "as": "jitter"
        },
        {
          "joinaggregate": [
            {"op": "median", "field": "value", "as": "median_value_per_category"},
            {"op": "max", "field": "value", "as": "max_value_per_category"}
          ],
          "groupby": ["category"]
        }
      ],
      "layer": [
        {
          "mark": "bar",
          "encoding": {
            "x": {
              "field": "category",
              "type": "nominal",
              "axis": {
                "title": "Composer",
                "labelAngle": 45
              }
            },
            "y": {
              "field": "value",
              "type": "quantitative",
              "aggregate": "q1",
              "axis": {"title": "Duration[second]"}
            },
            "y2": {
              "field": "value",
              "type": "quantitative",
              "aggregate": "q3"
            }
          }
        },
        {
          "mark": "rule",
          "encoding": {
            "x": {"field": "category", "type": "nominal"},
            "y": {"field": "value", "type": "quantitative", "aggregate": "min"},
            "y2": {"field": "value", "type": "quantitative", "aggregate": "max"}
          }
        },
        {
          "mark": {
            "type": "tick",
            "color": "black",
            "thickness": 2
          },
          "encoding": {
            "x": {"field": "category", "type": "nominal"},
            "y": {"field": "value", "type": "quantitative", "aggregate": "min"}
          }
        },
        {
          "mark": {
            "type": "tick",
            "color": "black",
            "thickness": 2
          },
          "encoding": {
            "x": {"field": "category", "type": "nominal"},
            "y": {"field": "value", "type": "quantitative", "aggregate": "max"}
          }
        },
        {
          "mark": {
            "type": "point",
            "color": "black",
            "size": 25,
            "filled": true
          },
          "encoding": {
            "x": {
              "field": "category",
              "type": "nominal",
              "axis": {"title": "Composer"},
              "offset": {"field": "jitter"}
            },
            "y": {"field": "value", "type": "quantitative"}
          }
        },
        {
          "mark": {
            "type": "text",
            "align": "center",
            "baseline": "bottom",
            "dy": -5,
            "fontSize": 10,
            "fontWeight": "bold",
            "color": "red"
          },
          "transform": [
            {
              "filter": "datum.value == datum.max_value_per_category"
            }
          ],
          "encoding": {
            "x": {"field": "category", "type": "nominal"},
            "y": {
              "field": "max_value_per_category",
              "type": "quantitative",
              "offset": 10
            },
            "text": {
              "field": "median_value_per_category",
              "type": "quantitative",
              "format": ".1f"
            }
          }
        }
      ]
    };

    vegaEmbed('#LengthOfExamplesByComposer', spec);

}



//////////////////////////////
//
// displayGenrePercentageDistribution --
//

function displayGenrePercentageDistribution() {

	let selector = document.querySelector("#GenrePercentageDistribution");
	if (!selector) {
		console.warn("Cannot find #GenrePercentageDistribution");
		return;
	}
	let data = {};
	for (let i=0; i<EXAMPLELIST.length; i++) {
		let value = EXAMPLELIST[i][INDEX_Genre];
		if (data[value]) {
			data[value]++;
		} else {
			data[value] = 1;
		}
	}

	let vdata = [];
	let keys = Object.keys(data).sort();
	for (let i=0; i<keys.length; i++) {
		let entry = {"name": keys[i], "y": data[keys[i]]};
		vdata.push(entry);
	}

	Highcharts.chart('GenrePercentageDistribution', {
		chart: { type: 'pie' },
		title: { text: null },
		credits: { enabled: false },
		tooltip: { pointFormat: '{series.name}: <b>{point.percentage:.1f}%</b>' },
		accessibility: { point: { valueSuffix: '%' } },
		plotOptions: {
			pie: {
				allowPointSelect: true,
				cursor: 'pointer',
				dataLabels: {
					enabled: true,
					format: '<b>{point.name}</b>: {point.percentage:.1f} %',
					connectorColor: 'silver',
					style: {
						color: 'black',
						textOutline: 'none'
					}
				}
			}
		},
		series: [{ name: 'Share', data: vdata }]
	});

}



//////////////////////////////
//
// displaySubgenrePercentageDistribution --
//

function displaySubgenrePercentageDistribution() {

	let selector = document.querySelector("#SubgenrePercentageDistribution");
	if (!selector) {
		console.warn("Cannot find #SubgenrePercentageDistribution");
		return;
	}
	let data = {};
	for (let i=0; i<EXAMPLELIST.length; i++) {
		let value = EXAMPLELIST[i][INDEX_Sub_Genre];
		if (!value) {
			continue;
		}
		let genre = EXAMPLELIST[i][INDEX_Genre];
		let label = `${genre}\t${value}`;
		if (data[label]) {
			data[label]++;
		} else {
			data[label] = 1;
		}
	}

	let color = {};
	color.Chamber      = "rgb(44,175,254)";
	color.Keyboard     = "rgb(44,175,254)";
	color.Concerto     = "#544fc5";
	color.Programmatic = "#544fc5";
	color.Symphonic    = "#544fc5";
	color.Ballet       = "#00e272";
	color.Opera        = "#00e272";
	color.Theatrical   = "#00e272";
	color.Choral       = "#fe6a35";
	color.Solo         = "#fe6a35";

	let vdata = [];
	let keys = Object.keys(data).sort();
	for (let i=0; i<keys.length; i++) {
		let entry = {"name": keys[i], "y": data[keys[i]]};
		vdata.push(entry);
	}
	vdata.sort((a, b) => {
		if (a.name < b.name) {
			return -1;
		}
		if (a.name > b.name) {
			return 1;
		}
			return 0;
		});
	for (let i=0; i<vdata.length; i++) {
		vdata[i].name = vdata[i].name.replace(/.*\t/, "");
		if (color[vdata[i].name]) {
			vdata[i].color = color[vdata[i].name];
		}
	}

	Highcharts.chart('SubgenrePercentageDistribution', {
		chart: { type: 'pie' },
		title: { text: null },
		credits: { enabled: false },
		tooltip: { pointFormat: '{series.name}: <b>{point.percentage:.1f}%</b>' },
		accessibility: { point: { valueSuffix: '%' } },
		plotOptions: {
			pie: {
				allowPointSelect: true,
				cursor: 'pointer',
				dataLabels: {
					enabled: true,
					format: '<b>{point.name}</b>: {point.percentage:.1f} %',
					connectorColor: 'silver',
					style: {
						color: 'black',
						textOutline: 'none'
					}
				}
			}
		},
		series: [{ name: 'Share', data: vdata }]
	});

}



//////////////////////////////
//
// displayCompositionYearByDecade --
//

function displayCompositionYearByDecade() {
	let tableElement = document.querySelector("#CompositionYearByDecadeTable");
	if (!tableElement) {
		console.log("Warning: Cannot find #CompositionYearByDecadeTable");
		return;
	}
	let graphElement = document.querySelector("#CompositionYearByDecadeGraph");
	if (!graphElement) {
		console.log("Warning: Cannot find #CompositionYearByDecadeGraph");
		return;
	}

	let decades = {};
	let keys = Object.keys(WORKINDEX);
	for (let i=0; i<keys.length; i++) {
		let value = WORKINDEX[keys[i]][0][INDEX_Composition_Year];
		if (!value) {
			continue;
		}
		if (!value.match(/^(\d{4})/)) {
			continue;
		}
		value = parseInt(value);
		let decade = parseInt(value/10) * 10;
		let label;
		if (decade < 1900) {
			label = "Pre-1900";
		} else if (decade >= 1950) {
			label = "1950 and later";
		} else {
			label = `${decade}s`;
		}
		if (decades[label]) {
			decades[label]++;
		} else {
			decades[label] = 1;
		}
	}
	console.log("DECADES", decades);

	let table  = `<table class="compyear">`;
	table     += "<tr><th>Composition&nbsp;Year</th><th>Count</th></tr>";
	let label  = "Pre-1900";
	table     += `<tr><td>${label}</td><td>${decades[label]}</td></tr>`;
	label      = "1900s";
	table     += `<tr><td>${label}</td><td>${decades[label]}</td></tr>`;
	label      = "1910s";
	table     += `<tr><td>${label}</td><td>${decades[label]}</td></tr>`;
	label      = "1920s";
	table     += `<tr><td>${label}</td><td>${decades[label]}</td></tr>`;
	label      = "1930s";
	table     += `<tr><td>${label}</td><td>${decades[label]}</td></tr>`;
	label      = "1940s";
	table     += `<tr><td>${label}</td><td>${decades[label]}</td></tr>`;
	label      = "1950 and later";
	table     += `<tr><td>${label}</td><td>${decades[label]}</td></tr>`;
	table     += "</table>";

	tableElement.innerHTML = table;

	let gdata = [];
	gdata[0] = {category: "<1900", value: decades["Pre-1900"]};
	gdata[1] = {category: "1900s", value: decades["1900s"]};
	gdata[2] = {category: "1910s", value: decades["1910s"]};
	gdata[3] = {category: "1920s", value: decades["1920s"]};
	gdata[4] = {category: "1930s", value: decades["1930s"]};
	gdata[5] = {category: "1940s", value: decades["1940s"]};
	gdata[6] = {category: ">=1950", value: decades["1950 and later"]};

	console.warn("GDATA", gdata);

	let spec = 


{
  "$schema": "https://vega.github.io/schema/vega-lite/v5.json",
  "description": "A bar chart showing values by category with preserved order and increased font size.",
  "width": 500,
  "height": 300,
  "data": {
    "values": [
      {"category": "<1900", "value": 16},
      {"category": "1900s", "value": 39},
      {"category": "1910s", "value": 71},
      {"category": "1920s", "value": 108},
      {"category": "1930s", "value": 87},
      {"category": "1940s", "value": 75},
      {"category": ">=1950", "value": 54}
    ]
  },
  "mark": {
    "type": "bar",
    "color": "#4682b4"
  },
  "encoding": {
    "x": {
      "field": "category",
      "type": "ordinal",
      "axis": {
        "labelAngle": 0,
        "title": "Decade",
        "labelFontSize": 12 * 1.2 // Increase font size by 20%
      },
      "sort": ["<1900", "1900s", "1910s", "1920s", "1930s", "1940s", ">=1950"]
    },
    "y": {
      "field": "value",
      "type": "quantitative",
      "axis": {"title": "Count"}
    }
  }
}



;

    vegaEmbed('#CompositionYearByDecadeGraph', spec);



}



</script>



